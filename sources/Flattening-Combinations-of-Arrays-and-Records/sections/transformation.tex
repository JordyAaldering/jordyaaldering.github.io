
\section{Transformation}\label{sec:transform}

Similarly to earlier approaches (Homann et al.~\cite{SoA}, Jubertie et al.~\cite{AoSoA}, Kofler et al.~\cite{AoSoA2}) we aim to improve the runtime performance of programs with records by transforming arrays of records into records of arrays.
However, we go one step further and remove records from programs entirely.
As discussed in Section~\ref{sec:key-idea} this transformation decreases the number of allocations and reference counting operations, as well as improving memory locality.
An additional benefit is that removing records from programs in their entirety decreases the implementation effort of adding records to the language, since no modifications to the type system and other existing compiler phases are necessary.
Especially in a large-scale project such as \sac{}, with many compiler phases that would require modifications to support records, such a transformation is paramount for a feasible implementation effort.

After the record transformation has been applied to a program, that program will no longer contain any record types.
Instead, all record arguments and variable declarations are replaced by distinct arrays.
Record constructors and field accessors and mutators are transformed into functions that operate on arrays instead.
Any user-defined functions and primitive operations on records are similarly transformed into operations on arrays.

In the case of \sac{} this record transformation is actually split up into two separate phases.
During the parsing phase we replace records by a temporary ``external'' type, which is only fully removed after the type checking phase.
This ensures that error messages generated by the type checker still pertain to record types without having to add support for records to the type checker, and that these error messages remain consistent with the pre-existing error messages.
For example we get the following error message if we try to add a body to a string.
%
\begin{lstlisting}[language=red]
No definition found for a function "ArrayArith::+" that accepts
an argument of type "_MAIN::_struct_Body" as parameter no 1.
Full argument types are "( _MAIN::_struct_Body, String::string)".
\end{lstlisting}
%
However had records already been transformed into distinct arrays, the error message would look as follows and the relation between the error and the actual written code would be lost.
%
\begin{lstlisting}[language=red]
No definition found for a function "Array::+" that
expects 4 argument(s) and yields 1 return value(s)
\end{lstlisting}
%
For the sake of brevity however, we omit this additional step in the following transformation rules because it is specific to \sac{} and is not relevant to the actual transformation of records to arrays.

% ----------------------------------------------------------------------

\input{sections/desugar}

\input{sections/expand}

\input{sections/denest}

% ----------------------------------------------------------------------

\subsection{Primitive Functions}

This record argument expansion applies to both the formal arguments of a function definition, and the actual arguments of applications of those functions.
Consequently, the number of formal arguments and the number of actual arguments of user-defined functions will remain equal after the record transformation.
Because of this no additional work is required for user-defined functions.

However in the case of primitive functions this leads to a problem.
The actual record arguments of primitive function applications will have been expanded into multiple arguments, but since these functions are defined as compiler primitives they do not have a corresponding function definition in the program.
As a result, the number of actual arguments and the number of expected arguments for these primitive functions will no longer be the same.
Since we expose record types to users as primitive types, we should also ensure that primitive operations on records are also possible.
Namely, we must ensure that it is possible to get the dimensionality and shape of a record array, and it should be possible to select into this array.
Additional work is required with regards to primitive function applications in order to ensure that they remain valid after the record transformation.

Consider the built-in \texttt{shape} primitive that we use in the running example to find the upper bound of the tensor comprehension.
Given a single array, this primitive function returns the shape of that array.
Such primitive functions should be applicable to arrays of records as well, for example to get the shape of an array of bodies.
After the transformation, records arguments will have been expanded into multiple arguments, leading to incorrect applications of these primitive functions.
For example,
%
\begin{lstlisting}
shp = shape(bodies);
\end{lstlisting}
%
will be transformed into an application without records
%
\begin{lstlisting}
shp = shape(bodies_pos, bodies_vel, bodies_mass);
\end{lstlisting}
%
This transformed code is no longer valid.
The shape primitive expects only a single argument, however it now receives three arguments.
To resolve this we might decide to arbitrarily take the first field of the record, in this case \texttt{bodies\_pos}, and use only that value in primitive functions instead.
However, this field might already have a shape within the record itself.
Such is the case with \texttt{bodies\_pos}, where \texttt{pos} itself is already a three-element integer vector.
After transformation, this shape will then be \texttt{[n,3]}, whereas given the definition of \texttt{bodies} in the argument \texttt{struct Body[n] bodies}, we would expect its shape to be \texttt{[n]}.

Here we can rely on the fact that record fields are always arrays of a statically known shape.
Because we know that \texttt{pos} is a one-dimensional vector, we can statically decide that the last element of the resulting shape vector (\texttt{[3]}) should be dropped from the resulting shape.
%
\begin{lstlisting}
shp = drop(-1, shape(bodies_pos));
\end{lstlisting}
%
We apply a similar approach to the remaining primitive functions that require modification, such as \texttt{dim} (dimensionality) and \texttt{sel} (selection).
However for the sake of brevity we omit those cases here.

% ----------------------------------------------------------------------

\subsection{Tensor Comprehension}

Whereas tensor comprehensions on records previously operated on only that single record value, after the record expansion these tensor comprehensions operate on and return multiple values.
For example, a tensor comprehension that generates a list of bodies
%
\begin{lstlisting}
bodies = { iv -> Body{} | iv < [N] };
\end{lstlisting}
%
is transformed into a tensor comprehension that returns three values:
%
\begin{lstlisting}
pos, vel, mass = { iv -> ([0,0,0], [0,0,0], 0) | iv < [N] };
\end{lstlisting}
%
This requires that tensor comprehensions, and similar constructions such as with-loops, are able to operate on and return multiple values.
In the case of \sac{}, this is already supported~\cite{sac-scan}.
